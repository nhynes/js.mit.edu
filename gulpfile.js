var gulp = require('gulp'),
    browserify = require('browserify'),
    buffer = require('vinyl-buffer'),
    concatCss = require('gulp-concat-css'),
    jscs = require('gulp-jscs'),
    jshint = require('gulp-jshint'),
    livereload = require('gulp-livereload'),
    minifyCss = require('gulp-minify-css'),
    plumber = require('gulp-plumber'),
    prefixer = require('gulp-autoprefixer'),
    uglify = require('gulp-uglify'),
    sass = require('gulp-sass'),
    source = require('vinyl-source-stream'),
    stylish = require('jshint-stylish'),
    watchify = require('watchify'),

    production = process.env.NODE_ENV === 'production',

    path = {
        src: {
            all: 'src/**/*',
            js: [ '!src/js/modals.js', 'src/js/*.js' ],
            main: './src/js/main.js',
            scss: 'src/**/*.scss',
            exerciseSCSS: 'src/exercises/**/*.scss',
            static: [ 'src/**/*.html', 'src/resources/**/*' ],
            exercises: 'src/exercises/**/*',
            exerciseJS: [ 'src/exercises/**/*.js', '!src/exercises/exercise.js' ]
        },
        dist: {
            base: 'dist/',
            all: 'dist/**/*',
            exercises: 'dist/exercises/'
        },
    },

    watching;

// *~ is generated by vim as temp file when saving atomically
function notilde( path ) {
    return [].concat( path, '!**/*~' );
}

gulp.task( 'build', [ 'scss', 'browserify', 'collectstatic', ] );
gulp.task( 'default', [ 'watch', 'build' ] );

gulp.task( 'checkstyle', function() {
    gulp.src( path.src.js )
        .pipe( plumber() )
        .pipe( jscs() )
        .pipe( jshint() )
        .pipe( jshint.reporter( stylish ) );
});

gulp.task( 'scss', function() {
    gulp.src( path.src.scss )
            .pipe( plumber() )
            .pipe( sass() )
            .pipe( minifyCss() )
            .pipe( concatCss('main.css') )
            .pipe( prefixer('> 5%') )
            .pipe( gulp.dest( path.dist.base ) );
    gulp.src( path.src.exerciseSCSS )
            .pipe( plumber() )
            .pipe( sass() )
            .pipe( minifyCss() )
            .pipe( concatCss('exercise.css') )
            .pipe( prefixer('> 5%') )
            .pipe( gulp.dest( path.dist.exercises ) );
});

gulp.task( 'browserify', function() {
    var bundler = browserify({
        cache: {}, packageCache: {}, fullPaths: true,
        entries: path.src.main,
        debug: !production
    });

    var bundle = function() {
        var stream = bundler.bundle()
            .on( 'error', function( e ) {
                console.error( '\x1b[31;1m', 'Browserify Error', e.toString(), '\x1b[0m' );
            })
            .pipe( source('bundle.js') );

        if ( production ) {
            stream = stream
                .pipe( buffer() )
                .pipe( uglify() )
        }

        stream.pipe( gulp.dest( path.dist.base ) );

        return stream;
    };

    if ( watching ) {
        bundler = watchify( bundler );
        bundler.on( 'update', bundle );
    }

    return bundle();
});

gulp.task( 'collectstatic', function() {
    gulp.src( notilde( path.src.static ) )
        .pipe( gulp.dest( path.dist.base ) );
    gulp.src( notilde( path.src.exercises ) )
        .pipe( gulp.dest( path.dist.exercises ) );
});

gulp.task( 'watch', function() {
    livereload({ silent: true });
    watching = true;
    gulp.watch( notilde( path.src.js ), [ 'checkstyle' ] );
    gulp.watch( notilde( path.src.exerciseSCSS ), [ 'scss' ] );
    gulp.watch( notilde( path.src.scss ), [ 'scss' ] );
    gulp.watch( notilde( path.src.static ), [ 'collectstatic' ] );
    gulp.watch( notilde( path.src.exercises ), [ 'collectstatic' ] );
    gulp.watch( notilde( path.dist.all ) ).on( 'change', livereload.changed );
    gulp.watch( notilde( path.src.exerciseJS ), function( change ) {
        if ( change.type !== 'changed' ) {
            return;
        }

        var bundler = browserify({
                cache: {}, packageCache: {}, fullPaths: true,
                entries: change.path,
                debug: !production
            }),
            changePath = change.path.split('/'),
            filename = 'bundle-' + changePath.pop(),
            destPath = changePath.join('/').replace( 'src', 'dist' ) + '/',
            bundle = function() {
                var stream = bundler.bundle()
                    .on( 'error', function( e ) {
                        console.error( '\x1b[31;1m', 'Browserify Error', e.toString(), '\x1b[0m' );
                    })
                    .pipe( source( filename ) );

                if ( production ) {
                    stream = stream
                        .pipe( buffer() )
                        .pipe( uglify() )
                }

                stream.pipe( gulp.dest( destPath ) );

                return stream;
            };

        bundle();
    });
});
