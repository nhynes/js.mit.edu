\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{minted}
\usepackage{setspace}
\usepackage{caption, newfloat}
\usepackage{upquote}

\renewcommand{\contentsname}{Topics}
\renewcommand*{\addcontentsline}[3]{\addtocontents{#1}{\protect\contentsline{#2}{#3}{}}}

\setlength{\marginparwidth}{1.2in}
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]%
{\raggedright\footnotesize #1}}

\newcommand{\todo}[1]{\marginpar{\color{red} #1}}

\newcommand{\adj}[1]{{\color{blue} #1}}

\newcommand{\say}[1]{{\color{magenta} #1}}

\renewcommand{\tt}[1]{\texttt{#1}}

\newenvironment{code}[3][false]
 {
  \VerbatimEnvironment

  \begin{lstlisting}
  \caption{#3}
  \begin{minted}[linenos=#1]{#2}}
 {
  \end{minted}
  \end{lstlisting}
 }


\DeclareFloatingEnvironment[placement={H}]{lstlisting}[Example][List of Listings]
\captionsetup[lstlisting]{box=colorbox,boxcolor=RoyalBlue,font={color=white, bf},labelsep=endash,skip=5pt}

\setlength{\headheight}{15pt}

\begin{document}

\title{Lecture 3: Events, Forms, and Animations}
\author{Nick Hynes}
\date{January 16, 2014}

\maketitle

\begin{spacing}{0}
\setcounter{tocdepth}{1}
\tableofcontents
\end{spacing}

\section{Events}
A GUI without user interaction is just a G! Therefore, the topic of today's class is creating JavaScript applications that respond to input from the user (and look good at the same time)!
\par
How does one do this? With events, of course! Why do I ask so many rhetorical questions? Why is this so self-referential?!? Anyway \ldots Basically, an event is a notification that is fired when something in the script's environment happens, like mouse clicks or text entry. In JavaScript, an event is represented as an Object that contains properties and methods that allow you to get information about, and interact with, the event.
\par
Given that we have a source, or emitter, of events, all we have to do is add code to ``listen'' for the appropriate event and call the desired function. The listener doesn't wait around polling for the event, though. Instead, it registers a \emph{callback} function with the browser's event dispatcher that gets called whenever the event is fired. This sort of callback-driven asynchrony is part of what makes JavaScript really unique.
\par
You can also create and dispatch custom events, but, for now, we'll focus on those generated by the browser. Let's start with an example that demonstrates how events work.
\begin{code}[true]{html}{Events make me feel bubbly}
<html>
<!-- omitting head for brevity -->
<body>
  <form onclick='console.log("form")'>
    <input type='button' onclick='console.log("button")'>
  </form>
</body>
</html>

When the button is clicked, the console will display:
"button"
"form"
\end{code}
There are a few interesting things happening in this example (none of which are real mouse clicks, however). On lines 4 and 5, we create a form and a button that have their \texttt{onclick} attributes set to JavaScript \texttt{console.log()} statements; this is how to add event listeners directly to HTML. Additionally, when the button is clicked, both the button and form have their listeners called, in that order. This demonstrates how events \emph{bubble} up the DOM tree.

\subsection{Types of events}
There are many different kinds of events that the browser emits (see \emph{Additional Resources} for a list (some are really cool!)), but the most important events for the purposes of basic application development (mostly DOM events) fall under the categories of: UIEvent, MouseEvent, KeyboardEvent, InputEvent, FocusEvent, and HashChangeEvent.

\subsubsection*{UIEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    scroll & When the user scrolls the element. The element
             must have overflow/a scroll bar. The element can be the window or another container element. \\
    \hline
    resize & When the user resizes the element (usually the
             window) \\
    \hline
  \end{tabular}
\end{center}
The \texttt{scroll} event can be attached to the \texttt{window}, \texttt{document}, or any DOM node and is fired when the user changes the scroll position of the element. If the element does not overflow or have scrollbars, this event will, naturally, never be triggered.
\\
The \texttt{resize} event can be attached to the \texttt{window} and \texttt{document} objects and is fired when either is resized (by changing the browser size or by zooming).

\subsubsection*{MouseEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    click & the user clicks the element. A click is the combination of a mousedown and mouseup. \\
    \hline
    dblclick & the user double clicks the element \\
    \hline
    mousedown & the user presses the mouse button on the
                element \\
    \hline
    mouseup & the user releases the mouse on an element.
              Note that the mouse did not have to start on the element. \\
    \hline
    mouseover & the user hovers the mouse over the
                element \\
     \hline
    mouseout & the user stops hovering the mouse over
               the element \\
    \hline
    mouseenter & Similar to mouseover except that this event
                 does not bubble \\
    \hline
    mouseleave & Similar to mouseover except does not
                 bubble \\
    \hline
  \end{tabular}
\end{center}
A MouseEvent listener can be attached to any DOM node. The MouseEvent object also has the following properties:
\begin{itemize}
\item \texttt{screenX}, \texttt{screenY} - the mouse's absolute x and y coordinates (relative to screen)
\item \texttt{clientX}, \texttt{clientY} - the mouse's x and y coordinates relative to the top left corner of the page
\item \texttt{ctrlKey}, 
\texttt{shiftKey}, \texttt{altKey}, \texttt{metaKey} - booleans that are set if the mouse event occurred while the  modifier key was pressed
\item \texttt{buttons} - The buttons that were pressed during the event. 0 is no button, 1 is the primary button (left), 2 is the secondary button (right), 3 is both 1 and 2, and 4 is the middle button, and so on.
\end{itemize}

\subsubsection*{KeyboardEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    keydown & the user presses a key on the keyboard \\
    \hline
    keyup & the user releases a key on the keyboard \\
    \hline
  \end{tabular}
\end{center}
A KeyboardEvent listener can be attached to the \texttt{window} object and any element. If attached to the \texttt{window}, the listener will be called if the user either presses or releases a key anywhere in the page. If attached to an element, the KeyboardEvent will only be triggered if the element is focused.
\par
The KeyboardEvent object, like the MouseEvent, also has the following useful properties:
\begin{itemize}
\item \tt{key} - a String representing the pressed key (only really useful for control/direction keys)
\item \tt{code} - the keycode for the pressed key. This will be the same for all keyboard mappings. The enter key has code 13.
\item \tt{ctrlKey, shiftKey, altKey, metaKey} - booleans that are set if a particular modifier key was pressed during the event
\end{itemize}
\par
Although this is one method of determining if the user has entered text into a form input, the next event is much better suited for the purpose.
\subsubsection*{InputEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    input & the user makes a change to an HTML input field
            or any element that has user-editable content \\
    \hline
  \end{tabular}
\end{center}
The InputEvent is generated when the user makes a change to an element that has editable content (e.g. a text box). Thus, the listeners for InputEvents should be attached to editable elements.
\subsubsection*{FocusEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    focus & the user focuses (tabs over to, makes a cursor
            appear in) an element. This event is dispatched after focus has shifted and does not bubble. \\
    \hline
    blur & the user removes focus from an element (by
           focusing another element). This event is dispatched after focus has shifted and does not bubble.\\
    \hline
    focusin & similar to focus except is dispatched before
              focus has shifted and does bubble \\
    \hline
    focusout & similar to blur except is dispatched before
               focus has shifted and does bubble \\
    \hline
  \end{tabular}
\end{center}
Very roughly, an element is focused when the user clicks on it or uses the tab button to select it. Though is usually most useful to attach listeners for FocusEvents to forms and their input elements, any element can be focused and have its FocusEvent listeners triggered. 
\subsubsection*{HashChangeEvent}
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Event name} & \textbf{When it's fired} \\
    \hline
    hashchange & when \texttt{window.location.hash} changes (the part
                 of the URL including and after the \#)  \\
    \hline
  \end{tabular}
\end{center}
Keep in mind that using JS to change \texttt{window.location.hash} will result in this event being fired.



\subsection{(De-)Registering and triggering event listeners}
\subsubsection*{Registering event listeners}
You've already seen one way to register events in the first example. This is done by setting the \texttt{onevent} attribute of the element to some JavaScript code.
\begin{Verbatim}[frame=single]
<tagname onevent="JavaScript code">
<!-- where event is the event for which to listen -->
\end{Verbatim}
Although this is a perfectly valid way of adding event listeners, when you dynamically create elements, it's much better to use one of the following methods since the previous method only allows one listener to be set per event (and also does not support all events).
\par
The preferred way to add an event listener using the DOM API is to call the \texttt{addEventListener} function of the selected element. Using jQuery, this most directly maps to the \texttt{on} function of the jQuery object called with two arguments.
\begin{Verbatim}[frame=single]
/* DOM API */
element.addEventListener("event", handlerFunction);

/* jQuery */
$jQueryObject.on("event", handlerFunction);

/* where event is the event type, like click, or mousemove,
and handlerFunction is a function that accepts one argument,
the eventObject (can be anonymous) */
//this in the handlerFunction is set to the listening DOM node
\end{Verbatim}
One thing to keep in mind, or rather, to not keep in mind, is that the jQuery event Object is almost entirely, but not completely like the Event object. More precisely, the jQuery object contains a superset of the properties of the Event object, so they can be used in the same way.
\par
jQuery also has a number of convenience methods that can either trigger or attach a new listener to an element. For example, you have:
\begin{itemize}
\item \texttt{\$jQueryObject.click([handler])} - when called with no arguments, ``clicks'' on the element or adds \texttt{handler} as a listener if present
\item \texttt{\$jQueryObject.focus([handler])} - focuses the element or adds the function \texttt{handler} as a focus listener
\item see \emph{Additional resources} for a link to more just like these
\end{itemize}
\begin{code}{javascript}{This example is not uneventful}
//Creates a button that, when clicked, displays a popup
var aButton = document.createElement("input");
aButton.type = "button";
aButton.value = "Click me!";
aButton.addEventListener("click", function() {
  alert("Thank you for making a simple button very happy.");
});
document.body.appendChild(aButton);

var $aButton = $("<input type='button' value='Click me!'>");
$aButton.click(function () {
  alert("Thank you for making a simple button very happy.");
});
$aButton.appendTo(document.body);
\end{code}

\subsubsection*{De-registering event listeners}
De-registering an event listener happens in much the same way as registration (well, as much as doing the exact opposition action can be).
\par
If the listener was attached using the \texttt{onevent} property of the element, then simply set the same property to \texttt{undefined}. If the listener was attached using the DOM API or jQuery, then use one of the following functions---preferably of the same variety as the one used to register the listener:
\begin{Verbatim}[frame=single]
/* DOM API */
element.removeEventListener("event", handlerFunction);

/* jQuery */
$jQueryObject.off("event", handlerFunction);

/* where event is the event type, like click, or mousemove,
and handlerFunction is a function that accepts one argument,
the eventObject (can be anonymous) */
\end{Verbatim}
See? They \emph{are} basically the same. One important thing to note is that you can't de-register an anonymous function since the de-registration functions look for, and remove, the Function that is equal to \texttt{handlerFunction}. To get around this, either declare a function using the standard \texttt{function functionName() \{\}} syntax or set the function equal to a variable, a la \texttt{var functionName = function() \{\}}.

\subsubsection*{Triggering event listeners}
Before we go on, I want to mention again that \texttt{this} in the event handler function is set to the DOM node for which the listener is registered. Okay, now that that's over with, let's continue.
\par
Sometimes you want to call the listeners attached to an element programmatically. There is a way to do this using the DOM API, but it's needlessly complicated and doesn't always work how you'd expect. Fortunately, jQuery allows you to do this in a transparent manner by using the convenience methods listed above, \texttt{trigger}, and \texttt{triggerHandler}. \texttt{trigger} can be a bit more involved so we'll get to that later. \texttt{triggerHandler}, on the other hand, is very friendly and easy to use: simply call it on a jQuery object with the event type as a String and it'll call all of the listeners bound to the element for that event type! This doesn't actually dispatch the event, though. Now, as promised, I present to you: \texttt{trigger}, a function that creates a real, live event and dispatches it to an element. This can either be called in the same way as \texttt{triggerHandler} with the event String or by creating and then calling it with a jQuery event object (the more involved part). Using the jQuery event object is only necessary when dispatching custom events.
\begin{Verbatim}[frame=single]
/* DOM method */
//Left as an exercise to the reader

/* jQuery method */
//To call an element's event listeners
$jQueryObject.triggerHandler("event");

//To dispatch an event to the element
$jQueryObject.trigger("event");
//or
var $jQueryEvent = jQuery.Event("eventname", [properties]);
$jQueryObject.trigger($jQueryEvent);
\end{Verbatim}

\subsection{Things you can do with Event objects}
\subsubsection*{Get the Event's info}
The most immediately useful properties of an Event object are \texttt{target} and \texttt{timestamp}. The former is the DOM node on which the event started (before the event started bubbling) and the latter is the time in milliseconds since the Unix epoch (1/1/1970. On 32-bit systems [using a signed integer], this will occur again on 19/1/2038).
\subsubsection*{Stop bubbling}
When working with an event that bubbles (most of them), it is sometimes desirable to stop the event from bubbling up the DOM tree. For instance, imagine a button that contains a drop-down arrow button; the click handler of the arrow button would need to stop the event from bubbling to prevent the containing button from being clicked. 
\begin{Verbatim}[frame=single]
//To stop event bubbling
eventObject.stopPropagation();

//To stop event bubbling and prevent other listeners on the
//same element from being triggered
eventObject.stopImmediatePropagation();
\end{Verbatim}
\subsubsection*{Cancel the event}
Certain events that have default actions are \emph{cancelable}, meaning that you can prevent the event from doing what it would normally do. This is done by calling the Event's \texttt{preventDefault} function.
\begin{Verbatim}[frame=single]
//To cancel an event/prevent its default action
eventObject.preventDefault();
\end{Verbatim}
Here's a list of cancelable events and what happens when they're canceled:
\begin{itemize}
\item keyup, keydown - prevents the key input from being sent to the element or the browser
\item mousedown - makes the element unleftclickable (this is totally a word)
\end{itemize}
It's a bit challenging to script a piece of paper/PDF document to make an example, so please try to use your imagination.
\begin{code}{javascript}{How to use JavaScript to troll your friends}
//This is unlikely to work in a page that has its own listeners
//You'd have to remove those first
window.addEventListener("mousedown", function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
  //results in nothing on the page being left-clickable
});
\end{code}
The \texttt{event.preventDefault()} method also works in jQuery. There are also better ways to cause trouble using JS (like putting an invisible, 100\%, fixed div in front of everything, or creating a browser extension that does this). Don't do that though\ldots

\section{Forms}
An HTML form, created using the \texttt{<form>} tag, is a container for user input elements, such as text inputs, checkboxes, buttons, and file uploads. In general, these are created using the void/self-closing \texttt{<input>} tag. The type of the input is specified by the element's \texttt{type} attribute. The \texttt{name} attribute of the item is the name of the data generated by the input (useful for HTTP submitted forms and checkboxes/radio buttons). In the spirit of the rest of the lists and tables in this lecture, here's a table of the more useful input types and a description of each:
\begin{center}
  \begin{tabular}{| c | p{10.4cm} |}
    \hline
    \textbf{Input type} & \textbf{Description} \\
    \hline
    text & A text box. Not very exciting, I know, but its
           metaphorical bread and butter of HTML forms. \\
    \hline
    password & Like a text box except the entered characters
               are hidden. For example, in your browser they are likely displayed as dots.  \\
    \hline
    checkbox & A checkbox \\
    \hline
    radio & A radio (multiple choice, single answer) button.
            Radio buttons with the same name are considered to be a group in which only one is selectable at a time. \\
    \hline 
    submit & A button that has the text ``Submit'' and the
             default action of submitting its parent form. \\
    \hline
    reset & A button that has the text ``Reset'' and the
            default action of resetting its parent form's fields. \\
    \hline
    button & A button. Does not contain text and has no
             default action. These can be styled and given click handlers, though. \\
    \hline
    hidden & A hidden form field. You can use this as a way
             to store and non-user-editable data to a webpage on form submit. \\
    \hline
    file & A file select control. Allows the user to select
           files from the system for upload. \\
    \hline
    email & A text box that is automatically validated as
            an email address (not quite as good as making your own regex, though). \\
    \hline
    url & A text box for URLs that is validated against
          the regex specified in the \texttt{pattern} attribute. \\
    \hline
  \end{tabular}
\end{center}
There are also two more input types that are non-void. These are \texttt{<textarea>}, which creates a multi-like text input, and \texttt{<button>}, which allows you to add content like images and text to the button. The inner HTML of the \texttt{<textarea>} is the default value. The \texttt{<button>} tag is particularly useful for making styled CSS buttons (an alternative is to style \texttt{<a>} elements).
\par
To get/set the contents of text fields/areas, file, and hidden inputs, and set the title of button \texttt{input}s and value of checkboxes/radio buttons, just modify the \texttt{value} property of the element or use the \texttt{val} function of its jQuery object.
\begin{samepage}
\begin{Verbatim}[frame=single]
//To get/set the value/user input of an input-type element
/* DOM API */
var value = element.value;        //getter
element.value = "someValue";      //setter

/* jQuery */
var value = $jQueryObject.val();  //getter
$jQueryObject.val("someValue");   //setter
\end{Verbatim}
\end{samepage}
To determine whether a checkbox or radio button is selected, simply query its \texttt{checked} property which is a Boolean that indicates its checked status.
\begin{Verbatim}[frame=single]
//To get the value of the checked element (radio or checkbox)
/* DOM API */
var checkables = document.getElementsByName("inputName");
for(var i = 0; i < checkables.length; i++) {
  if(checkables.item(i).checked) {
    console.log(checkables.item(i).value);
  }
}

/* jQuery */
var $checked = $("selector").filter(':checked');
var response = $checked.val();
\end{Verbatim}
Input elements also have a variety of attributes that allow you to do things like disabling them, making them required, or read-only using the \texttt{disabled}, \texttt{required}, and \texttt{read-only} Boolean attributes. Another new feature that was accomplished using events and whatnot back in the day is the placeholder: now, all you have to do is set the \texttt{placeholder} attribute and the browser takes care of the rest. Additionally, there is a \texttt{pattern} attribute that validates the form contents against a regular expression.
\begin{code}{html}{A formidable form}
<html>
<!-- head and jQuery omitted for brevity -->
<body>
  <form onsubmit='submitForm()' action='javascript:void(0)'>
    <input type='text' placeholder='Username' id='username'>
    <br>
    <input type='password' placeholder='Password' 
    id='password'>
    <br>
    <input type='checkbox' checked='true' id='keepLogged'>
    Keep me logged in.
    <br>
    <input type='submit' value='Submit'>
  </form>
  <script type='application/javascript'>
    function submitForm() {
      var username = $("#username").val();
      var password = $("#password").val();
      var stayLoggedIn = $('#keepLogged').attr("checked");
      doLogin(username, password, stayLoggedIn);

      alert("None shall pass.");
    }
  </script>
</body>
</html>
\end{code}
In this example, we create a simple HTML form that contains three input fields; two text boxes for the user's username and password, and a checkbox to give the user the option to stay logged in that is selected by default. There is also a submit button that submits the form when clicked.
\par
The form, itself, has a listener attached to its \texttt{submit} event (an event that is unique to forms) that calls the \texttt{submitForm} function when the form is (you'll never guess this) submitted. The default action of a form submit is to direct the browser to the URL specified by the \texttt{action} property. However, since this is Introduction to JavaScript and not Introduction to PHP, Ruby, Django, or otherwise, we're going to keep the action (no pun intended) on the client side and use a technique known as AJAX to communicate with the server, which we'll cover in the next class. To this end, the \texttt{action} attribute is set to the special value \texttt{javascript:void(0)}, which is a sort of JavaScript ``URL'' that does nothing and, thus, prevents the page from reloading. 

\section{Animations}
With the introduction of CSS3, animations became infinitely easier (not to mention better looking!). For historical purposes, I'll provide a quick description of how it was done in ye olde days (circa 2008, but realistically 2011 after it gained more browser support). Essentially, a JavaScript timer was set that incrementally moved a CSS property from one value to another. As you may imagine this was tedious to write and not very efficient, but even then, there were jQuery functions to do just this. In today's shiny, modern browsers, smooth transitions are created simply by setting the CSS \texttt{transition} property, changing the desired style, and then watching the browser's native implementation do the rest of the work. This is truly a good world.
\subsection{Animation using transitions}
To enable transitions on an element, as stated before, simply set its \texttt{transition} CSS property. The \texttt{transition} property has the following syntax:
\begin{Verbatim}[frame=single]
transition: css-prop duration [timing-function] [delay], ...;
/* timing-function and delay are optional parameters */

/* or use all to animate all CSS properties */
transition: all duration [timing-funciton] [delay];
\end{Verbatim}
Multiple transitioned properties can be achieved by using the \texttt{all} keyword or adding more transitions separated by commas.
\par
That's about all there is to CSS animations! Now you're able to create fancy, functional web application GUIs! 

\subsection{Timing}
In JavaScript, there are two main ways to execute code after a certain amount of time, \texttt{setTimeout} and \texttt{setInterval}. \texttt{setTimeout} simply calls a function after the specified time while \texttt{setInterval} calls the function repeatedly for every unit of the specified time that passes. While the timing functions are useful for much more than animations, they're included here for their value in creating multi-step animations using transitions!
\par
There is an event for the end of a transition, but it's not fully supported yet. If you'd like to use it, however, the event name is \texttt{transitioned} and \texttt{webkitTransitionEnd} (which is what I meant by not fully supported).
\begin{Verbatim}[frame=single]
//To call a function after a certain amount of time
var ref = setTimeout(callback, timeInMilliseconds);
clearTimeout(ref); //stops the timeout

//To call a function periodically
var ref = setInterval(callback, timeInMilliseconds);
clearInterval(ref); //stops the interval
\end{Verbatim}
In the following example you can see how transitions can be combined with timing functions (specifically a recursive \texttt{setTimeout}) to create an animation that vaguely resembles a bouncing ball. 
\par
\subsection{jQuery UI}
The jQuery UI extension/library has functions that allow you to trigger simple effects as well as create a variety of widgets (many of which already exist natively in HTML5 (which you should use instead)). You can find a link to documentation on jQuery UI in the \emph{Additional resources} section. However, to pique your interest, I shall provide as an example a snippet that shakes an element up and down.
\begin{Verbatim}[frame=single]
//With jQuery UI imported,
$jQueryObject.effect("bounce"); //Wow, that was easy
\end{Verbatim}
\begin{code}{html}{Not an accurate physical representation}
<html>
<head>
  <style type='text/css'>
    .bouncingBall {
      transition: top 250ms linear;
      width: 100px; height: 100px;
      border-radius: 100px; /* makes a circle */
      position: absolute;
      top: 70%;
      background-color: red;
    }
  </style>
</head>
<body>
  <div class="bouncingBall"></div>
  <!-- jQuery import omitted for brevity -->
  <script type='application/javascript'>
    function bouncyAnimation(maxHeight, goingUp) {
      var $bouncy = $(".bouncingBall");
      maxHeight = maxHeight || $bouncy.css("top");
      if(goingUp) {
        $bouncy.css("top", maxHeight);
        setTimeout(function() {
          bouncyAnimation(maxHeight, false); }, 250); 
      } else {
        var screenBottom = window.innerHeight;
        var elemHeight = $bouncy.height();
        $bouncy.css("top", screenBottom - elemHeight);
        setTimeout(function() {
          bouncyAnimation(maxHeight, true); }, 250); 
      }
    }
    bouncyAnimation(); //make the magic happen
  </script>
</body>
</html>
\end{code}
\end{document}