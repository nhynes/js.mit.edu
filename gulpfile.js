var gulp = require('gulp'),
    browserify = require('browserify'),
    buffer = require('vinyl-buffer'),
    concatCss = require('gulp-concat-css'),
    jscs = require('gulp-jscs'),
    jshint = require('gulp-jshint'),
    livereload = require('gulp-livereload'),
    minifyCss = require('gulp-minify-css'),
    plumber = require('gulp-plumber'),
    prefixer = require('gulp-autoprefixer'),
    uglify = require('gulp-uglify'),
    sass = require('gulp-sass'),
    source = require('vinyl-source-stream'),
    stylish = require('jshint-stylish'),
    watchify = require('watchify'),

    production = process.env.NODE_ENV === 'production',

    path = {
        src: {
            all: 'src/**/*',
            js: [ '!src/js/modals.js', 'src/js/*.js' ],
            main: './src/js/main.js',
            scss: 'src/scss/*.scss',
            static: [ 'src/**/*.html', 'src/resources/**/*' ]
        },
        dist: {
            base: 'dist/',
            all: 'dist/**/*',
        },
    },

    watching;

// *~ is generated by vim as temp file when saving atomically
function notilde( path ) {
    return [].concat( path, '!**/*~' );
}

gulp.task( 'build', [ 'scss', 'browserify', 'collectstatic', ] );
gulp.task( 'default', [ 'checkstyle', 'watch', 'build' ] );

gulp.task( 'checkstyle', function() {
    gulp.src( path.src.js )
        .pipe( plumber() )
        .pipe( jscs() )
        .pipe( jshint() )
        .pipe( jshint.reporter( stylish ) );
});

gulp.task( 'scss', function() {
    gulp.src( path.src.scss )
            .pipe( plumber() )
            .pipe( sass() )
            .pipe( minifyCss() )
            .pipe( concatCss('main.css') )
            .pipe( prefixer('> 5%') )
            .pipe( gulp.dest( path.dist.base ) );
});

gulp.task( 'browserify', function() {
    var bundler = browserify({
        cache: {}, packageCache: {}, fullPaths: true,
        entries: path.src.main,
        debug: !production
    });

    var bundle = function() {
        var stream = bundler.bundle()
            .on( 'error', function( e ) {
                console.error( '\x1b[31;1m', 'Browserify Error', e.toString(), '\x1b[0m' );
            })
            .pipe( source('bundle.js') );

        if ( production ) {
            stream = stream
                .pipe( buffer() )
                .pipe( uglify() )
        }

        stream.pipe( gulp.dest( path.dist.base ) );

        return stream;
    };

    if ( watching ) {
        bundler = watchify( bundler );
        bundler.on( 'update', bundle );
    }

    return bundle();
});

gulp.task( 'collectstatic', function() {
    gulp.src( notilde( path.src.static ) )
        .pipe( gulp.dest( path.dist.base ) );
});

gulp.task( 'watch', function() {
    livereload({ silent: true });
    watching = true;
    gulp.watch( notilde( path.src.js ), [ 'checkstyle' ] );
    gulp.watch( notilde( path.src.scss ), [ 'scss' ] );
    gulp.watch( notilde( path.src.static ), [ 'collectstatic' ] );
    gulp.watch( notilde( path.dist.all ) ).on( 'change', livereload.changed );
});
